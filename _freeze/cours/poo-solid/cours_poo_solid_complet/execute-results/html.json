{
  "hash": "3109c4d1a25afcd1241793d55f382842",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Programmation Orientée Objet et Principes SOLID en Python\"\nsubtitle: \"De la théorie à la pratique\"\n---\n\n::: {.callout-tip}\n## Version interactive\n[Ouvrir ce cours dans Binder](https://mybinder.org/v2/gh/adreux/peregrinations-pythonesques/HEAD)\n:::\n\n# Introduction\n\n## Pourquoi la POO ?\n\n**Problème sans POO :**  \nImaginez gérer une bibliothèque avec des dictionnaires et des fonctions dispersées.\n\n::: {#bde109ae .cell execution_count=1}\n``` {.python .cell-code}\nbook1 = {\"titre\": \"1984\", \"auteur\": \"Orwell\", \"disponible\": True}\nbook2 = {\"titre\": \"Dune\", \"auteur\": \"Herbert\", \"disponible\": False}\n\ndef borrow_book(book):\n    if book[\"disponible\"]:\n        book[\"disponible\"] = False\n        return True\n    return False\n\nprint(f\"Emprunt réussi : {borrow_book(book1)}\")\nprint(f\"Livre 1 : {book1}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmprunt réussi : True\nLivre 1 : {'titre': '1984', 'auteur': 'Orwell', 'disponible': False}\n```\n:::\n:::\n\n\n::: {.callout-warning}\n## Problèmes sans POO\n- Pas de validation des données\n- Code dupliqué partout\n- Difficile à maintenir et déboguer\n- Pas de cohérence entre les objets\n- Impossible de tracer les modifications\n:::\n\n**Avec la POO :**\n- Encapsulation : données et comportements regroupés\n- Réutilisabilité : héritage et composition\n- Maintenabilité : modifications localisées\n- Debugging facilité : logs et tracés centralisés\n\n# Concepts Fondamentaux\n\n## Classes et Instances\n\nUne classe est un **modèle** pour créer des objets.\n\n::: {#bc654767 .cell execution_count=2}\n``` {.python .cell-code}\nimport logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] - %(message)s\"\n)\n\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n        self.available = True\n\nbook = Book('1984', 'George Orwell')\nlogging.info(f\"Livre créé : {book}\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,101 [INFO] - Livre créé : <__main__.Book object at 0x1055211b0>\n```\n:::\n:::\n\n\n## Méthodes magiques\n\n### `__str__` : Représentation lisible\n\n`__str__` définit comment un objet est affiché pour un humain (print, logs), au lieu d'une représentation technique inutile.\n\n::: {#9e38ab26 .cell execution_count=3}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n        self.available = True\n    \n    def __str__(self):\n        return f\"{self.title} – {self.author}\"\n\nbook = Book('1984', 'George Orwell')\nlogging.info(f\"Livre : {book}\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,104 [INFO] - Livre : 1984 – George Orwell\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Bonne pratique\nDéfinissez toujours `__str__` pour faciliter le debugging et les logs.\n:::\n\n### `__eq__` : Comparaison d'égalité\n\n`__eq__` définit quand deux objets doivent être considérés égaux par leur contenu, et non par leur identité.\n\n::: {#75c10218 .cell execution_count=4}\n``` {.python .cell-code}\n# Sans __eq__\nbook1 = Book('1984', 'George Orwell')\nbook2 = Book('1984', 'George Orwell')\nprint(f\"Égaux sans __eq__ ? {book1 == book2}\")  # False\n\n# Avec __eq__\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n        self.available = True\n    \n    def __str__(self):\n        return f\"{self.title} – {self.author}\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Book):\n            return NotImplemented\n        return self.title == other.title and self.author == other.author\n\nbook1 = Book('1984', 'George Orwell')\nbook2 = Book('1984', 'George Orwell')\nprint(f\"Égaux avec __eq__ ? {book1 == book2}\")  # True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nÉgaux sans __eq__ ? False\nÉgaux avec __eq__ ? True\n```\n:::\n:::\n\n\n::: {.callout-important}\n## Important\nSans `__eq__`, Python compare les identités (adresses mémoire), pas le contenu.\n:::\n\n## Dataclasses : Simplification moderne\n\nLes dataclasses automatisent la création de `__init__`, `__repr__`, `__eq__` et plus encore.\n\n::: {#61151145 .cell execution_count=5}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    available: bool = True\n\nbook1 = Book('1984', 'George Orwell')\nbook2 = Book('1984', 'George Orwell')\n\nprint(book1)\nprint(f\"Égaux ? {book1 == book2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBook(title='1984', author='George Orwell', available=True)\nÉgaux ? True\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Avantages des dataclasses\n- Moins de code boilerplate\n- Type hints intégrés (meilleure documentation)\n- Valeurs par défaut simples\n- Représentation automatique lisible\n:::\n\n### Quand utiliser les dataclasses ?\n\n**Utilisez les dataclasses pour :**\n- Classes \"conteneurs\" de données (DTO, modèles)\n- Configuration d'objets\n- Résultats de calculs\n\n**Évitez pour :**\n- Classes avec beaucoup de logique métier\n- Héritage complexe\n- Besoin de contrôle fin sur `__init__`\n\n## Encapsulation\n\nProtéger les données internes avec des attributs privés/protégés.\n\n::: {#942f7374 .cell execution_count=6}\n``` {.python .cell-code}\nclass BankAccount:\n    def __init__(self, initial_balance):\n        self.__balance = initial_balance  # Privé (__)\n\n    def deposit(self, amount):\n        if amount <= 0:\n            raise ValueError(\"Le montant à déposer doit être positif\")\n        self.__balance += amount\n        logging.info(f\"Dépôt de {amount}€. Nouveau solde : {self.__balance}€\")\n\n    def get_balance(self):\n        return self.__balance\n\naccount = BankAccount(100)\naccount.deposit(50)\nprint(f\"Solde : {account.get_balance()}€\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,116 [INFO] - Dépôt de 50€. Nouveau solde : 150€\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nSolde : 150€\n```\n:::\n:::\n\n\n**Avantages :**\n- Contrôle des accès\n- Validation des modifications\n- Protection contre les erreurs\n\n## Héritage\n\nRéutiliser du code en créant des sous-classes.\n\n::: {#cf785081 .cell execution_count=7}\n``` {.python .cell-code}\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n        logging.info(f\"Utilisateur créé : {name}\")\n\nclass Librarian(User):\n    def __init__(self, name, email, department):\n        super().__init__(name, email)  # Appelle le constructeur parent\n        self.department = department\n        self.permissions = [\"borrow\", \"add_book\", \"delete_book\"]\n        logging.info(f\"Bibliothécaire créé : département {department}\")\n\nlibrarian = Librarian(\"Marie\", \"marie@library.com\", \"Histoire\")\nprint(f\"Permissions : {librarian.permissions}\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,120 [INFO] - Utilisateur créé : Marie\n2026-01-23 16:41:44,121 [INFO] - Bibliothécaire créé : département Histoire\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPermissions : ['borrow', 'add_book', 'delete_book']\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Le rôle de super()\n`super().__init__()` appelle le constructeur de la classe parente pour initialiser les attributs qu'elle gère, avant d'ajouter nos propres attributs spécifiques.\n\nQuand `Librarian` hérite de `User`, on doit d'abord initialiser les attributs communs (`name`, `email`) avec `super().__init__(name, email)`, puis ajouter les attributs spécifiques au bibliothécaire (`department`). Sans `super()`, les attributs du parent ne seraient pas initialisés.\n:::\n\n## Polymorphisme\n\nMême interface, comportements différents.\n\n::: {#d7bce0cf .cell execution_count=8}\n``` {.python .cell-code}\nclass Document:\n    def __init__(self, title):\n        self.title = title\n    \n    def display(self):\n        raise NotImplementedError\n\nclass Book(Document):\n    def display(self):\n        return f\"Livre: {self.title}\"\n\nclass Magazine(Document):\n    def display(self):\n        return f\"Magazine: {self.title}\"\n\n# Test polymorphique\ndocuments = [\n    Book(\"1984\"),\n    Magazine(\"National Geographic\")\n]\n\nfor doc in documents:\n    print(doc.display())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLivre: 1984\nMagazine: National Geographic\n```\n:::\n:::\n\n\n# Décorateurs Python\n\n## @property - Propriétés gérées\n\nTransformer une méthode en attribut accessible avec validation.\n\n::: {#1e95e5f8 .cell execution_count=9}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title, price):\n        self._title = title\n        self._price = price\n\n    @property\n    def price(self):\n        \"\"\"Getter\"\"\"\n        logging.info(f\"[LOG] Accès au prix de '{self._title}'\")\n        return self._price\n\n    @price.setter\n    def price(self, new_price):\n        \"\"\"Setter avec validation\"\"\"\n        if new_price < 0:\n            raise ValueError(\"Le prix ne peut pas être négatif\")\n        logging.info(f\"[LOG] Prix modifié: {self._price} → {new_price}\")\n        self._price = new_price\n\nbook = Book(\"1984\", 15.99)\nprint(f\"Prix initial : {book.price}€\")\nbook.price = 12.99\nprint(f\"Nouveau prix : {book.price}€\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,129 [INFO] - [LOG] Accès au prix de '1984'\n2026-01-23 16:41:44,129 [INFO] - [LOG] Prix modifié: 15.99 → 12.99\n2026-01-23 16:41:44,129 [INFO] - [LOG] Accès au prix de '1984'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix initial : 15.99€\nNouveau prix : 12.99€\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Pourquoi utiliser un setter ?\nLe setter permet d'ajouter de la validation et du contrôle quand on modifie un attribut, au lieu de laisser n'importe quelle valeur être assignée directement.\n\nSans setter, on pourrait écrire `book.price = -50` et Python accepterait sans vérifier. Le setter intercepte toute modification de `price` pour :\n- Vérifier que la valeur est valide (pas négative)\n- Logger le changement pour le debugging\n- Garantir la cohérence des données\n:::\n\n**Avantages pour le debugging :**\n- Logs automatiques sur les accès\n- Validation centralisée\n- Traçabilité des modifications\n\n## @staticmethod - Méthodes utilitaires\n\nMéthodes sans accès à l'instance ou la classe.\n\n::: {#b479f53f .cell execution_count=10}\n``` {.python .cell-code}\nclass LibraryUtils:\n    @staticmethod\n    def format_isbn(isbn):\n        \"\"\"Formatage ISBN sans besoin de l'instance\"\"\"\n        return f\"{isbn[:3]}-{isbn[3:4]}-{isbn[4:9]}-{isbn[9:12]}-{isbn[12]}\"\n\nisbn = \"9782070368228\"\nformatted = LibraryUtils.format_isbn(isbn)\nprint(f\"ISBN formaté : {formatted}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nISBN formaté : 978-2-07036-822-8\n```\n:::\n:::\n\n\n**Quand l'utiliser :**\n- Fonctions utilitaires liées conceptuellement à la classe\n- Pas besoin de `self` ou `cls`\n\n## @classmethod - Méthodes de classe\n\nMéthodes avec accès à la classe (pas l'instance).\n\n::: {#00e77e79 .cell execution_count=11}\n``` {.python .cell-code}\nclass Book:\n    total_count = 0\n\n    def __init__(self, title):\n        self.title = title\n        Book.total_count += 1\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Factory method - constructeur alternatif\"\"\"\n        return cls(data['title'])\n\n    @classmethod\n    def get_total_count(cls):\n        return cls.total_count\n\nbook1 = Book(\"1984\")\nbook2 = Book.from_dict({'title': 'Dune'})\nprint(f\"Nombre total de livres : {Book.get_total_count()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNombre total de livres : 2\n```\n:::\n:::\n\n\n**Avantages :**\n- Constructeurs alternatifs (factory methods)\n- Accès aux variables de classe\n- Utile pour le tracking\n\n## @abstractmethod - Classes abstraites\n\nForcer l'implémentation dans les sous-classes.\n\n::: {#ee4bfcd4 .cell execution_count=12}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass Borrowable(ABC):\n    @abstractmethod\n    def borrow(self):\n        pass\n\n    @abstractmethod\n    def return_item(self):\n        pass\n\nclass Book(Borrowable):\n    def __init__(self, title):\n        self.title = title\n        self.available = True\n\n    def borrow(self):\n        if not self.available:\n            raise Exception(f\"Le livre '{self.title}' n'est pas disponible\")\n        self.available = False\n        return f\"Livre '{self.title}' emprunté\"\n\n    def return_item(self):\n        self.available = True\n        return f\"Livre '{self.title}' retourné\"\n\nbook = Book(\"1984\")\nprint(book.borrow())\nprint(book.return_item())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLivre '1984' emprunté\nLivre '1984' retourné\n```\n:::\n:::\n\n\n**Avantages :**\n- Contrat d'interface clair\n- Erreurs à la création, pas à l'exécution\n- Documentation du comportement attendu\n\n# Principes SOLID\n\n## S - Single Responsibility Principle\n\n**Principe :** Une classe = une responsabilité.\n\n::: {.panel-tabset}\n\n## Mauvais exemple\n\n```python\nclass Book:\n    def __init__(self, title):\n        self.title = title\n\n    def borrow(self):\n        pass\n\n    def send_reminder_email(self):\n        # PROBLÈME : Book ne devrait pas gérer les emails\n        pass\n\n    def save_to_db(self):\n        # PROBLÈME : Book ne devrait pas gérer la DB\n        pass\n```\n\n## Bon exemple\n\n::: {#a7adaa37 .cell execution_count=13}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Book:\n    \"\"\"Responsabilité : Représenter un livre\"\"\"\n    title: str\n    author: str\n    available: bool = True\n\n@dataclass\nclass Borrow:\n    book: Book\n    user: str\n    borrow_date: datetime\n\nclass BorrowManager:\n    \"\"\"Responsabilité : Gérer les emprunts\"\"\"\n    def borrow_book(self, book, user):\n        if book.available:\n            book.available = False\n            borrow = Borrow(book, user, datetime.now())\n            logging.info(f\"Emprunt créé : {book.title} par {user}\")\n            return borrow\n        raise Exception(f\"Livre non disponible : {book.title}\")\n\nclass EmailService:\n    \"\"\"Responsabilité : Envoyer des emails\"\"\"\n    def send_reminder(self, borrow):\n        logging.info(f\"Email envoyé pour : {borrow.book.title}\")\n\n# Test\nbook = Book(\"1984\", \"George Orwell\")\nmanager = BorrowManager()\nemail_service = EmailService()\n\nborrow = manager.borrow_book(book, \"Alice\")\nemail_service.send_reminder(borrow)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,145 [INFO] - Emprunt créé : 1984 par Alice\n2026-01-23 16:41:44,146 [INFO] - Email envoyé pour : 1984\n```\n:::\n:::\n\n\n:::\n\n**Avantages debugging :**\n- Erreur d'email ? Chercher dans `EmailService` uniquement\n- Problème de BDD ? Chercher dans `BookRepository`\n- Logs plus clairs et ciblés\n\n## O - Open/Closed Principle\n\n**Principe :** Ouvert à l'extension, fermé à la modification.\n\n::: {.panel-tabset}\n\n## Mauvais exemple\n\n```python\nclass DiscountCalculator:\n    def calculate(self, user_type, amount):\n        if user_type == \"student\":\n            return amount * 0.9\n        elif user_type == \"senior\":\n            return amount * 0.85\n        elif user_type == \"vip\":\n            return amount * 0.8\n        return amount\n        # Problème : Ajouter un nouveau type = modifier cette classe\n```\n\n## Bon exemple\n\n::: {#3e60bb8f .cell execution_count=14}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass DiscountStrategy(ABC):\n    @abstractmethod\n    def apply(self, amount):\n        pass\n\nclass StudentDiscount(DiscountStrategy):\n    def apply(self, amount):\n        return amount * 0.9\n\nclass SeniorDiscount(DiscountStrategy):\n    def apply(self, amount):\n        return amount * 0.85\n\nclass VIPDiscount(DiscountStrategy):\n    def apply(self, amount):\n        return amount * 0.8\n\nclass User:\n    def __init__(self, name, discount_strategy):\n        self.name = name\n        self.discount_strategy = discount_strategy\n\n    def calculate_price(self, amount):\n        return self.discount_strategy.apply(amount)\n\n# Test\nstudent = User(\"Alice\", StudentDiscount())\nsenior = User(\"Bob\", SeniorDiscount())\n\nprint(f\"Prix étudiant : {student.calculate_price(100)}€\")\nprint(f\"Prix senior : {senior.calculate_price(100)}€\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix étudiant : 90.0€\nPrix senior : 85.0€\n```\n:::\n:::\n\n\n:::\n\n**Avantages :**\n- Ajouter une nouvelle remise = créer une nouvelle classe\n- Code existant non modifié = moins de bugs\n- Tests unitaires isolés\n\n## L - Liskov Substitution Principle\n\n**Principe :** Les sous-classes doivent pouvoir remplacer leurs classes parentes.\n\n::: {.panel-tabset}\n\n## Mauvais exemple\n\n```python\nclass Bird:\n    def fly(self):\n        return \"Je vole\"\n\nclass Penguin(Bird):\n    def fly(self):\n        raise Exception(\"Je ne peux pas voler!\")\n        # PROBLÈME : Penguin ne peut pas remplacer Bird\n```\n\n## Bon exemple\n\n::: {#599ff2b9 .cell execution_count=15}\n``` {.python .cell-code}\nclass Document:\n    def __init__(self, title):\n        self.title = title\n\n    def can_be_borrowed(self):\n        return True\n\nclass Book(Document):\n    def can_be_borrowed(self):\n        return True  # Cohérent avec Document\n\nclass ArchiveDocument(Document):\n    def can_be_borrowed(self):\n        return False  # Cohérent, juste une réponse différente\n\ndef display_availability(document: Document):\n    status = \"disponible\" if document.can_be_borrowed() else \"archivé\"\n    print(f\"{document.title}: {status}\")\n\n# Test\nbook = Book(\"1984\")\narchive = ArchiveDocument(\"Manuscrit ancien\")\n\ndisplay_availability(book)\ndisplay_availability(archive)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1984: disponible\nManuscrit ancien: archivé\n```\n:::\n:::\n\n\n:::\n\n## I - Interface Segregation Principle\n\n**Principe :** Interfaces spécifiques plutôt qu'une interface générale.\n\n::: {.panel-tabset}\n\n## Mauvais exemple\n\n```python\nclass Printable(ABC):\n    @abstractmethod\n    def print(self):\n        pass\n\n    @abstractmethod\n    def scan(self):\n        pass\n\n    @abstractmethod\n    def fax(self):\n        pass\n\nclass SimplePrinter(Printable):\n    def print(self):\n        return \"Impression...\"\n\n    def scan(self):\n        raise NotImplementedError(\"Pas de scanner!\")\n\n    def fax(self):\n        raise NotImplementedError(\"Pas de fax!\")\n```\n\n## Bon exemple\n\n::: {#134e057e .cell execution_count=16}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass Printable(ABC):\n    @abstractmethod\n    def print(self):\n        pass\n\nclass Scannable(ABC):\n    @abstractmethod\n    def scan(self):\n        pass\n\nclass Faxable(ABC):\n    @abstractmethod\n    def fax(self):\n        pass\n\nclass SimplePrinter(Printable):\n    def print(self):\n        return \"Impression...\"\n\nclass MultifunctionPrinter(Printable, Scannable, Faxable):\n    def print(self):\n        return \"Impression...\"\n\n    def scan(self):\n        return \"Scan...\"\n\n    def fax(self):\n        return \"Fax...\"\n\n# Test\nsimple = SimplePrinter()\nmultifunction = MultifunctionPrinter()\n\nprint(simple.print())\nprint(multifunction.scan())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImpression...\nScan...\n```\n:::\n:::\n\n\n:::\n\n## D - Dependency Inversion Principle\n\n**Principe :** Dépendre d'abstractions, pas d'implémentations concrètes.\n\n::: {.panel-tabset}\n\n## Mauvais exemple\n\n```python\nclass MySQLDatabase:\n    def save(self, data):\n        print(\"Sauvegarde dans MySQL\")\n\nclass BorrowManager:\n    def __init__(self):\n        self.db = MySQLDatabase()  # Dépendance forte !\n\n    def record_borrow(self, borrow):\n        self.db.save(borrow)\n        # Impossible de tester avec une fausse DB\n        # Impossible de changer vers PostgreSQL facilement\n```\n\n## Bon exemple\n\n::: {#4a36ad0b .cell execution_count=17}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\nclass DatabaseInterface(ABC):\n    @abstractmethod\n    def save(self, data):\n        pass\n\nclass MySQLDatabase(DatabaseInterface):\n    def save(self, data):\n        logging.info(f\"[MySQL] Sauvegarde: {data}\")\n\nclass PostgreSQLDatabase(DatabaseInterface):\n    def save(self, data):\n        logging.info(f\"[PostgreSQL] Sauvegarde: {data}\")\n\nclass FakeDatabase(DatabaseInterface):\n    \"\"\"Pour les tests\"\"\"\n    def save(self, data):\n        logging.info(f\"[FAKE] Sauvegarde: {data}\")\n\nclass BorrowManager:\n    def __init__(self, database: DatabaseInterface):\n        self.db = database  # Injection de dépendance\n\n    def record_borrow(self, borrow):\n        self.db.save(borrow)\n\n# Utilisation\n@dataclass\nclass Book:\n    title: str\n\n@dataclass\nclass Borrow:\n    book: Book\n    user: str\n\ndb_prod = MySQLDatabase()\nmanager_prod = BorrowManager(db_prod)\n\ndb_test = FakeDatabase()\nmanager_test = BorrowManager(db_test)\n\nborrow = Borrow(Book(\"1984\"), \"Alice\")\nmanager_prod.record_borrow(borrow)\nmanager_test.record_borrow(borrow)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,163 [INFO] - [MySQL] Sauvegarde: Borrow(book=Book(title='1984'), user='Alice')\n2026-01-23 16:41:44,163 [INFO] - [FAKE] Sauvegarde: Borrow(book=Book(title='1984'), user='Alice')\n```\n:::\n:::\n\n\n:::\n\n**Avantages pour le debugging :**\n- Tests isolés avec fausses dépendances\n- Logs différents selon l'environnement\n- Changement de DB sans toucher au code métier\n\n# Cas pratique : Debugging\n\n## Sans POO - Cauchemar du debugging\n\n```python\ndef borrow_book(books, book_id, user_id):\n    book = books[book_id]\n    if book[\"available\"]:\n        book[\"available\"] = False\n        # Où logger ? Quelle fonction a causé l'erreur ?\n        return True\n    return False\n```\n\n**Problèmes :**\n- Pas de traçabilité\n- Erreurs silencieuses\n- Impossible de savoir qui a modifié quoi\n\n## Avec POO - Debugging structuré\n\n::: {#78bdeee5 .cell execution_count=18}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n@dataclass\nclass Book:\n    title: str\n    _available: bool = True\n    \n    @property\n    def available(self):\n        return self._available\n\n    @available.setter\n    def available(self, value):\n        logging.info(\n            f\"'{self.title}' - Disponibilité: {self._available} → {value}\"\n        )\n        self._available = value\n\n@dataclass\nclass Borrow:\n    book: Book\n    user: str\n    borrow_date: datetime = None\n    \n    def __post_init__(self):\n        if self.borrow_date is None:\n            self.borrow_date = datetime.now()\n        logging.info(\n            f\"Emprunt créé: '{self.book.title}' par {self.user} \"\n            f\"à {self.borrow_date}\"\n        )\n\n# Test\nbook = Book(\"1984\")\nbook.available = False\nborrow = Borrow(book, \"Alice\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2026-01-23 16:41:44,168 [INFO] - '1984' - Disponibilité: True → False\n2026-01-23 16:41:44,168 [INFO] - Emprunt créé: '1984' par Alice à 2026-01-23 16:41:44.168362\n```\n:::\n:::\n\n\n**Avantages :**\n- Logs automatiques et structurés\n- Traçabilité complète\n- Facile de retrouver l'origine d'une erreur\n\n# Résumé\n\n## Avantages de la POO\n\n### Maintenance\n- Code organisé et modulaire\n- Modifications localisées\n- Réutilisation par héritage/composition\n\n### Debugging\n- Logs centralisés par classe\n- Traçabilité via `@property`\n- Erreurs plus précises\n\n### Évolutivité\n- SOLID garantit l'extensibilité\n- Tests unitaires isolés\n- Nouveaux features sans casser l'existant\n\n### Collaboration\n- Interfaces claires\n- Responsabilités définies\n- Documentation naturelle via les classes\n\n## Conclusion\n\n::: {.callout-note}\n## Points clés\nLa POO n'est pas juste une façon d'organiser du code, c'est un outil pour :\n- **Penser** en termes de responsabilités\n- **Debugger** efficacement avec des logs structurés\n- **Faire évoluer** le code sans tout casser\n- **Collaborer** avec des interfaces claires\n\nLes principes SOLID sont des garde-fous qui vous éviteront des heures de debugging et de refactoring.\n:::\n\n::: {.callout-tip}\n## Conseil final\nCommencez simple, refactorisez quand la complexité augmente, et testez chaque classe individuellement.\n:::\n\n",
    "supporting": [
      "cours_poo_solid_complet_files"
    ],
    "filters": [],
    "includes": {}
  }
}